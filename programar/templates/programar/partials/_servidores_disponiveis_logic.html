<script>
(function () {
  'use strict';

  // Namespace
  const NS = window.PROGRAMAR = window.PROGRAMAR || {};

  // ================== DEFAULTS (único) ==================
  const DEFAULTS = {
    targetSelector:  '#servidoresLivres, #poolServidores, .js-servidores-livres',
    badgeSelector:   '#countServidoresLivres',
    expedienteSelector: '#expedienteAdmin, .js-expediente-admin',
    expedienteBadgeSelector: '#countExpedienteAdmin',
    excludeAllocated: false,
    cardSelectorInMetas: '.servidor-chip, .srv-chip, .chip-servidor, [data-servidor-id], .servidor-card',
    cardIdAttr:  'data-id',
    itemIdAttr:  'data-id',
    renderItem:  defaultRenderItem,
    autofillExpediente: false // padrão: NÃO auto-preencher
  };
  // permitir overrides via NS.defaults.servidores
  Object.assign(DEFAULTS, (NS.defaults && NS.defaults.servidores) || {});

  // ================== Utils DOM/HTML ==================
  function escapeHtml(s){
    return String(s ?? '')
      .replaceAll('&','&amp;').replaceAll('<','&lt;')
      .replaceAll('>','&gt;').replaceAll('"','&quot;')
      .replaceAll("'","&#039;");
  }
  function getContainer(sel){ return document.querySelector(sel); }

  function getBadgeForContainer(containerEl, explicitSelector) {
    if (explicitSelector) {
      const el = document.querySelector(explicitSelector);
      if (el) return el;
    }
    const card = containerEl?.closest?.('.card');
    return card ? card.querySelector('.card-header .badge') : null;
  }

  function setBadgeFor(containerEl, count, explicitSelector) {
    const badge = getBadgeForContainer(containerEl, explicitSelector);
    if (badge) badge.textContent = String(count);
  }

  function updateBadges(opts){
    const pool = getContainer(opts.targetSelector);
    const exp  = getContainer(opts.expedienteSelector);
    if (pool) setBadgeFor(pool, pool.children.length, opts.badgeSelector);
    if (exp)  setBadgeFor(exp,  exp.children.length,  opts.expedienteBadgeSelector);
  }

  function defaultRenderItem(servidor){
    const el = document.createElement('div');
    el.className = 'servidor-card';
    el.setAttribute('draggable','true'); // mantém DnD
    el.dataset.id = servidor.id;
    el.innerHTML = `
      <span class="srv-icon"><i class="bi bi-person-fill"></i></span>
      <span class="srv-name">${escapeHtml(servidor.nome)}</span>`;
    return el;
  }
  function defaultRenderExpedienteItem(servidor){
    const el = document.createElement('div');
    el.className = 'servidor-card';
    el.dataset.id = servidor.id;   // no expediente, sem draggable
    el.innerHTML = `
      <span class="srv-icon"><i class="bi bi-person-fill"></i></span>
      <span class="srv-name">${escapeHtml(servidor.nome)}</span>`;
    return el;
  }

  function getAllocatedIds(opts){
    if (!opts.excludeAllocated) return new Set();

    // Escopo restrito: SOMENTE dentro dos cards de metas
    const metasScope = document.getElementById('metaCardsContainer');
    if (!metasScope) return new Set();

    const ids = new Set();
    metasScope.querySelectorAll('.servidor-chip, [data-servidor-id], .servidor-card').forEach(el => {
      const sid = el.getAttribute(opts.cardIdAttr) || el.dataset.id || el.dataset.servidorId;
      if (sid) ids.add(String(sid));
    });
    return ids;
  }


  // ======= Render "por diff" (preserva a ordem atual) =======
  function diffRenderPool(target, livres, opts){
    const livresIds = new Set(livres.map(s => String(s.id)));

    // remove quem não está mais na lista
    Array.from(target.children).forEach(child => {
      const sid = child.getAttribute(opts.itemIdAttr) || child.dataset.id || child.dataset.servidorId;
      if (!sid || !livresIds.has(String(sid))) child.remove();
    });

    const presentes = new Set(
      Array.from(target.children).map(ch => String(ch.getAttribute(opts.itemIdAttr) || ch.dataset.id || ch.dataset.servidorId))
    );

    livres.forEach(s => {
      const sid = String(s.id);
      if (presentes.has(sid)) return;
      const el = opts.renderItem(s);
      if (!el.getAttribute(opts.itemIdAttr)) el.setAttribute(opts.itemIdAttr, sid);
      target.appendChild(el);
    });

    setBadgeFor(target, target.children.length, opts.badgeSelector);
  }

  function renderExpedienteFromLivres(livres, opts){
    const exp = getContainer(opts.expedienteSelector);
    if (!exp) return;
    exp.innerHTML = '';
    livres.forEach(s => exp.appendChild(defaultRenderExpedienteItem(s)));
    setBadgeFor(exp, exp.children.length, opts.expedienteBadgeSelector);
  }

  const isISODate = (s) => /^\d{4}-\d{2}-\d{2}$/.test(String(s||''));

  // ================== FETCH + APLICAR ==================
  async function loadServidoresDisponiveis(iso, options = {}){
    const opts = { ...DEFAULTS, ...options };
    console.debug('[programar] loadServidoresDisponiveis v3', {
      iso, opts, progLoaded: document.body.dataset.progLoaded
    });

    const urlBase = NS?.urls?.servidores;
    if (!urlBase) {
      console.error('[programar] URL programar:servidores_para_data não definida.');
      return { livres: [], impedidos: [] };
    }
    if (!isISODate(iso)) {
      console.warn('[programar] Data inválida:', iso);
      return { livres: [], impedidos: [] };
    }

    const target = getContainer(opts.targetSelector);
    if (target) {
      target.classList.add('is-loading');
      target.innerHTML = `<div class="text-muted">Carregando…</div>`;
      setBadgeFor(target, 0, opts.badgeSelector);
    }

    try {
      const url = new URL(urlBase, window.location.origin);
      url.searchParams.set('data', iso);
      const resp = await fetch(url.toString(), { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const json = await resp.json();

   
      let livres = Array.isArray(json.livres) ? json.livres : [];
      const impedidos = Array.isArray(json.impedidos) ? json.impedidos : [];
      // garante que impedidos não apareçam no pool
      const impedidosIds = new Set(
        impedidos.map(i => String(i.id ?? i.sid ?? '')).filter(Boolean)
      );
      if (impedidosIds.size) {
        livres = livres.filter(s => !impedidosIds.has(String(s.id)));
      }

      // Remove da pool quem já está alocado nos cards (se habilitado)
      if (opts.excludeAllocated) {
        const alocados = getAllocatedIds(opts);
        if (alocados.size) {
          livres = livres.filter(s => !alocados.has(String(s.id)));
        }
      }

      // Render da pool por diff
      if (target) {
        target.classList.add('servidores-grid');
        target.innerHTML = '';
        diffRenderPool(target, livres, opts);
        target.classList.remove('is-loading');
      }

      // Render da tabela de impedidos (se existir)
      (function renderImpedidos(){
        const tbody = document.querySelector('#tabelaImpedidos tbody');
        const badge = document.getElementById('countImpedidos');
        if (!tbody) return;

        const esc = (s)=>String(s??'')
          .replaceAll('&','&amp;').replaceAll('<','&lt;')
          .replaceAll('>','&gt;').replaceAll('"','&quot;')
          .replaceAll("'",'&#039;');

        if (!impedidos.length) {
          tbody.innerHTML = `<tr><td colspan="2" class="text-muted">Nenhum servidor impedido.</td></tr>`;
          if (badge) badge.textContent = '0';
        } else {
          tbody.innerHTML = impedidos.map(i => {
            const nome = i.nome ?? i.name ?? i.servidor ?? i.servidor_nome ?? '';
            const motivo = i.motivo ?? i.reason ?? i.justificativa ?? '';
            return `<tr><td>${esc(nome)}</td><td>${esc(motivo)}</td></tr>`;
          }).join('');
          if (badge) badge.textContent = String(impedidos.length);
        }
      })();

      // Auto-preencher expediente? Só se pedido + sem chips + sem progLoaded
      (function maybeAutofillExpediente(){
        const expEl = getContainer(opts.expedienteSelector);
        if (!expEl) return;

        const hasChipsInCards = document.querySelector(
          '.meta-dropzone .servidor-chip, .meta-dropzone .servidor-card, .drop-target .servidor-chip, .drop-target .servidor-card'
        );
        const progLoadedFlag = document.body.dataset.progLoaded === '1';

        const shouldAutofill = !!opts.autofillExpediente && !hasChipsInCards && !progLoadedFlag;
        console.debug('[programar] autofillExpediente?', shouldAutofill, {
          requested: opts.autofillExpediente, hasChipsInCards: !!hasChipsInCards, progLoadedFlag
        });

        if (shouldAutofill) {
          renderExpedienteFromLivres(livres, opts);
        } else {
          setBadgeFor(expEl, expEl.children.length, opts.expedienteBadgeSelector);
        }
      })();

      // Badges finais
      updateBadges(opts);

      document.dispatchEvent(new CustomEvent('programar:servidoresLoaded', {
        detail: { iso, livres, impedidos }
      }));

      return { livres, impedidos };
    } catch (err) {
      console.error('[programar] Falha ao carregar servidores:', err);
      if (target) {
        target.innerHTML = `<div class="text-danger">Erro ao carregar.</div>`;
        target.classList.remove('is-loading');
      }
      return { livres: [], impedidos: [] };
    }
  }

  // ================== Observers (mantém badges) ==================
  function wireBadgeObservers(options = {}){
    const opts = { ...DEFAULTS, ...options };
    let poolObsAttached = false;
    let expObsAttached  = false;

    const tryAttach = () => {
      const pool = getContainer(opts.targetSelector);
      const exp  = getContainer(opts.expedienteSelector);

      if (pool && !poolObsAttached) {
        new MutationObserver(() => updateBadges(opts)).observe(pool, { childList: true });
        poolObsAttached = true;
      }
      if (exp && !expObsAttached) {
        new MutationObserver(() => updateBadges(opts)).observe(exp, { childList: true });
        expObsAttached = true;
      }
      if (poolObsAttached && expObsAttached) installer.disconnect();
    };

    const installer = new MutationObserver(tryAttach);
    installer.observe(document.documentElement, { childList: true, subtree: true });
    tryAttach(); // tentativa imediata
  }
  document.addEventListener('DOMContentLoaded', () => wireBadgeObservers());

  // ================== Integrações convenientes ==================
  document.addEventListener('shown.bs.modal', async (ev) => {
    if (!ev.target.matches('#programar-modalAtividade')) return;
    const hidden = document.getElementById('programar-dataAtividade') ||
                   document.getElementById('programar-data') ||
                   document.querySelector('[data-programar-data]');
    const iso = hidden?.value || hidden?.getAttribute?.('data-programar-data') || new Date().toISOString().slice(0,10);

    // Autopreencher só se ainda não houve prefill/salvamento
    const wantAuto = (document.body.dataset.progLoaded === '1') ? false : true;
    await loadServidoresDisponiveis(iso, {
    autofillExpediente: wantAuto,
    excludeAllocated: false    // <- garantir que o pool não desconte atividades
    });
    });

  document.addEventListener('programar:diaSelecionado', async (e) => {
    const iso = e?.detail?.iso;
    if (!iso) return;
    const wantAuto = (document.body.dataset.progLoaded === '1') ? false : true;
    await loadServidoresDisponiveis(iso, { autofillExpediente: wantAuto });
  });

  // ================== API pública ==================
  NS.loadServidores = NS.loadServidoresDisponiveis = loadServidoresDisponiveis;

})();
</script>
