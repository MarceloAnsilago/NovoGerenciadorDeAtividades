<script>
(function () {
  const NS = (window.PROGRAMAR = window.PROGRAMAR || {});
  if (NS._metasLogicLoaded) return;
  NS._metasLogicLoaded = true;

  function escapeSelector(value) {
    const raw = String(value ?? "");
    if (window.CSS && typeof window.CSS.escape === "function") {
      try { return window.CSS.escape(raw); } catch (_) { return raw; }
    }
    return raw.replace(/["\\]/g, "\\$&");
  }

  function highlightExistingCard(metaId) {
    const container = document.getElementById("metaCardsContainer");
    if (!container) return;
    const card = container.querySelector(`[data-meta-id="${escapeSelector(metaId)}"]`);
    if (!card) return;
    card.classList.add("border-warning");
    card.scrollIntoView({ behavior: "smooth", block: "center" });
    setTimeout(() => card.classList.remove("border-warning"), 1500);
  }

  function confirmLimite(programadasAtual, alocado) {
    if (alocado <= 0 || programadasAtual < alocado) return true;
    return window.confirm(
      `Esta meta já possui ${programadasAtual} atividade${programadasAtual === 1 ? "" : "s"} em programação ` +
      `para a unidade, igual ou maior que o total alocado (${alocado}). Deseja programar mesmo assim?`
    );
  }

  function confirmDuplicado(existingCards) {
    if (existingCards <= 0) return true;
    const mensagem = existingCards === 1
      ? "Já existe uma atividade desta meta programada para este dia. Deseja inserir outra?"
      : `Já existem ${existingCards} atividades desta meta programadas para este dia. Deseja inserir mais uma?`;
    return window.confirm(mensagem);
  }

  NS.loadMetas = async function (dateStr = null) {
    const metasGrid = document.getElementById("metasGrid");
    if (!metasGrid) return;

    metasGrid.innerHTML = `
      <div class="placeholder-glow">
        <span class="placeholder col-12 mb-2"></span>
      </div>
    `;

    let url = NS.urls?.metas;
    if (!url) {
      metasGrid.innerHTML = `<div class="alert alert-danger">Endpoint de metas não configurado.</div>`;
      return;
    }
    if (dateStr) {
      url += (url.includes("?") ? "&" : "?") + "data=" + encodeURIComponent(dateStr);
    }

    try {
      const resp = await fetch(url, { headers: { "X-Requested-With": "XMLHttpRequest" } });
      const data = await resp.json();

      if (!data.metas || !Array.isArray(data.metas) || data.metas.length === 0) {
        metasGrid.innerHTML = `<div class="alert alert-light border mb-0">Nenhuma meta disponível.</div>`;
        return;
      }

      metasGrid.innerHTML = data.metas.map((m) => {
        const programadas = Number(m.programadas_total || 0);
        const alocado = Number(m.alocado_unidade || 0);
        return `
          <button type="button"
                  class="meta-card"
                  data-id="${m.id}"
                  data-programadas="${programadas}"
                  data-alocado="${alocado}"
                  data-month="${m.data_limite ? (new Date(m.data_limite).getFullYear() + '-' + String(new Date(m.data_limite).getMonth()+1).padStart(2,'0')) : 'nodate'}">
            <div class="meta-head">
              <span class="icon"><i class="bi bi-flag"></i></span>
              <h6 class="meta-title">${m.nome}</h6>
            </div>
            <div class="meta-sep"></div>
            ${m.data_limite ? `
              <div class="meta-date">
                <i class="bi bi-calendar-event"></i>
                <span>Data limite:</span>
                <strong>${new Date(m.data_limite).toLocaleDateString('pt-BR')}</strong>
              </div>
            ` : ""}
            <div class="meta-small mt-2">Em programação: <b>${programadas}</b></div>
            <div class="meta-small mt-1">Alocado nesta unidade: <b>${alocado}</b></div>
            <div class="meta-progress mt-1">
              <div class="d-flex justify-content-between summary mb-1">
                <span>Executado (unidade)</span>
                <span><b>${m.executado_unidade || 0}</b> / ${m.alocado_unidade || 0}</span>
              </div>
              <div class="progress"><div class="progress-bar bg-primary" style="width:${(m.alocado_unidade ? Math.min(100, Math.round((m.executado_unidade/m.alocado_unidade)*100)) : 0)}%"></div></div>
            </div>
          </button>
        `;
      }).join("");

      // === Abas por mês (filtro visual) ===
      try{
        const months = []; const labels = {};
        (data.metas||[]).forEach(m=>{
          let key='nodate', lab='Sem data';
          if (m.data_limite){ const d=new Date(m.data_limite); const k=d.getFullYear()+'-'+String(d.getMonth()+1).padStart(2,'0'); key=k; try{ const t=d.toLocaleDateString('pt-BR',{month:'long',year:'numeric'}); lab=t.charAt(0).toUpperCase()+t.slice(1);}catch(_){ lab=k; } }
          if (!months.includes(key)){ months.push(key); labels[key]=lab; }
        });
        // garante exibir a aba do mês selecionado
        if (dateStr){ const d=new Date(dateStr); const sel=d.getFullYear()+'-'+String(d.getMonth()+1).padStart(2,'0'); if (!months.includes(sel)){ months.push(sel); try{ const t=d.toLocaleDateString('pt-BR',{month:'long',year:'numeric'}); labels[sel]=t.charAt(0).toUpperCase()+t.slice(1);}catch(_){ labels[sel]=sel; } } }
        {
          let cur = (dateStr ? (new Date(dateStr).getFullYear()+'-'+String(new Date(dateStr).getMonth()+1).padStart(2,'0')) : (months[0]||''));
          const parts = ["<ul class='nav nav-tabs mb-2' id='metasTabs' role='tablist'>"];
          parts.push(`<li class='nav-item' role='presentation'><button class='nav-link ${!cur?'active':''}' data-key='' type='button' role='tab'>Todos</button></li>`);
          months.forEach(k=>{ const active=(k===cur); parts.push(`<li class='nav-item' role='presentation'><button class='nav-link ${active?'active':''}' data-key='${k}' type='button' role='tab'>${labels[k]}</button></li>`); });
          parts.push("</ul>");
          // coloca abas acima do grid
          metasGrid.insertAdjacentHTML('beforebegin', parts.join(''));
          function applyFilter(key){ metasGrid.querySelectorAll('.meta-card').forEach(c=>{ const mk=c.getAttribute('data-month')||'nodate'; c.style.display = (!key || mk===key) ? '' : 'none'; }); const tabs = metasGrid.previousElementSibling?.querySelectorAll?.('.nav-link') || []; tabs.forEach(b=>{ b.classList.toggle('active', b.getAttribute('data-key')===key); }); }
          const tabContainer = metasGrid.previousElementSibling; tabContainer?.querySelectorAll?.('.nav-link')?.forEach(btn=>{ btn.addEventListener('click', ()=> applyFilter(btn.getAttribute('data-key'))); });
          applyFilter(cur);
        }
      }catch(_e){}

      metasGrid.querySelectorAll(".meta-card").forEach((card) => {
        card.addEventListener("click", () => {
          metasGrid.querySelectorAll(".meta-card").forEach((c) => c.classList.remove("selected"));
          card.classList.add("selected");

          const metaId = card.dataset.id;
          if (!metaId) return;

          const programadas = Number(card.dataset.programadas || "0") || 0;
          const alocado = Number(card.dataset.alocado || "0") || 0;
          const container = document.getElementById("metaCardsContainer");
          const selector = `[data-meta-id="${escapeSelector(metaId)}"]`;
          const cards = container ? Array.from(container.querySelectorAll(selector)) : [];
          const existingCards = cards.length;
          const novosNaoSalvos = cards.filter((c) => !c.dataset.itemId).length;
          const totalAtual = programadas + novosNaoSalvos;

          if (!confirmLimite(totalAtual, alocado)) return;

          const metaTitulo = card.querySelector(".meta-title")?.textContent?.trim() || "";
          const options = {};
          if (existingCards > 0) {
            if (!confirmDuplicado(existingCards)) {
              highlightExistingCard(metaId);
              return;
            }
            options.forceNew = true;
          }

          window.PROGRAMAR?.ensureMetaCard?.(metaId, metaTitulo, options);
        });
      });
    } catch (err) {
      metasGrid.innerHTML = `<div class="alert alert-danger">Erro ao carregar metas.</div>`;
      console.error(err);
    }
  };
})();
</script>
