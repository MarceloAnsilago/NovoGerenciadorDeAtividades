<script>
(function () {
  const NS = (window.PROGRAMAR = window.PROGRAMAR || {});
  if (NS._metasLogicLoaded) return;
  NS._metasLogicLoaded = true;

  function escapeSelector(value) {
    const raw = String(value ?? "");
    if (window.CSS && typeof window.CSS.escape === "function") {
      try { return window.CSS.escape(raw); } catch (_) { return raw; }
    }
    return raw.replace(/["\\]/g, "\\$&");
  }

  function escapeHtml(value) {
    return String(value ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function monthKeyToNumber(key) {
    const raw = String(key || "");
    const match = raw.match(/^(\d{4})-(\d{2})$/);
    if (!match) return null;
    const year = Number(match[1]);
    const month = Number(match[2]);
    if (!Number.isFinite(year) || !Number.isFinite(month) || month < 1 || month > 12) return null;
    return year * 100 + month;
  }

  function monthKeyFromDateString(value) {
    const raw = String(value || "").trim();
    const match = raw.match(/^(\d{4})-(\d{2})/);
    if (!match) return "";
    return `${match[1]}-${match[2]}`;
  }

  function parseYearKey(value) {
    const raw = String(value || "").trim();
    if (!raw || raw === "nodate") return null;
    const parsed = Number(raw);
    return Number.isFinite(parsed) ? parsed : null;
  }

  function cardMatchesYear(card, selectedYear) {
    if (!selectedYear) return true;
    const startYear = parseYearKey(card.getAttribute("data-start-year"));
    const endYear = parseYearKey(card.getAttribute("data-end-year"));

    if (selectedYear === "nodate") {
      return startYear === null && endYear === null;
    }

    const y = parseYearKey(selectedYear);
    if (y === null) return true;
    if (startYear !== null && y < startYear) return false;
    if (endYear !== null && y > endYear) return false;
    return true;
  }

  function highlightExistingCard(metaId) {
    const container = document.getElementById("metaCardsContainer");
    if (!container) return;
    const card = container.querySelector(`[data-meta-id="${escapeSelector(metaId)}"]`);
    if (!card) return;
    card.classList.add("border-warning");
    try {
      if (window.PROGRAMAR?.autoScrollModal) {
        card.scrollIntoView({ behavior: "smooth", block: "center" });
      }
    } catch(_e) {}
    setTimeout(() => card.classList.remove("border-warning"), 1500);
  }

  function confirmLimite(programadasAtual, alocado) {
    if (alocado <= 0 || programadasAtual < alocado) return true;
    return window.confirm(
      `Esta meta já possui ${programadasAtual} atividade${programadasAtual === 1 ? "" : "s"} em programação ` +
      `para a unidade, igual ou maior que o total alocado (${alocado}). Deseja programar mesmo assim?`
    );
  }

  function confirmDuplicado(existingCards) {
    if (existingCards <= 0) return true;
    const mensagem = existingCards === 1
      ? "Já existe uma atividade desta meta programada para este dia. Deseja inserir outra?"
      : `Já existem ${existingCards} atividades desta meta programadas para este dia. Deseja inserir mais uma?`;
    return window.confirm(mensagem);
  }

  NS.loadMetas = async function (dateStr = null) {
    const metasGrid = document.getElementById("metasGrid");
    if (!metasGrid) return;
    const monthFromDate = monthKeyFromDateString(dateStr);
    NS.metaDateMonth = monthFromDate;
    if (monthFromDate) {
      NS.metaMonthSelected = monthFromDate;
      NS.metaYearSelected = monthFromDate.slice(0, 4);
    }

    const STATUS_LABELS = {
      andamento: "Em andamento",
      concluida: "Concluída",
      encerrada: "Encerrada",
    };
    metasGrid.innerHTML = `
      <div class="placeholder-glow">
        <span class="placeholder col-12 mb-2"></span>
      </div>
    `;

    let url = NS.urls?.metas;
    if (!url) {
      metasGrid.innerHTML = `<div class="alert alert-danger">Endpoint de metas não configurado.</div>`;
      return;
    }
    if (dateStr) {
      url += (url.includes("?") ? "&" : "?") + "data=" + encodeURIComponent(dateStr);
    }

    try {
      const resp = await fetch(url, { headers: { "X-Requested-With": "XMLHttpRequest" } });
      const data = await resp.json();

      if (!data.metas || !Array.isArray(data.metas) || data.metas.length === 0) {
        metasGrid.innerHTML = `<div class="alert alert-light border mb-0">Nenhuma meta disponível.</div>`;
        return;
      }

      metasGrid.innerHTML = data.metas.map((m) => {
        const programadas = Number(m.programadas_total || 0);
        const alocado = Number(m.alocado_unidade || 0);
        const executado = Number(m.executado_unidade || 0);
        const dInicio = m.data_inicio ? new Date(m.data_inicio) : null;
        const dLimite = m.data_limite ? new Date(m.data_limite) : null;
        const startMonthKey = dInicio ? (dInicio.getFullYear() + "-" + String(dInicio.getMonth() + 1).padStart(2, "0")) : "nodate";
        const endMonthKey = dLimite ? (dLimite.getFullYear() + "-" + String(dLimite.getMonth() + 1).padStart(2, "0")) : "nodate";
        const startYearKey = dInicio ? String(dInicio.getFullYear()) : "nodate";
        const endYearKey = dLimite ? String(dLimite.getFullYear()) : "nodate";
        const monthKey = endMonthKey;
        const yearKey = dLimite ? String(dLimite.getFullYear()) : (dInicio ? String(dInicio.getFullYear()) : "nodate");
        const statusKey = String(m.status || "andamento").toLowerCase();
        const normalizedStatus = STATUS_LABELS[statusKey] ? statusKey : "andamento";
        const statusLabel = m.status_label || STATUS_LABELS[normalizedStatus] || STATUS_LABELS.andamento;
        const statusLabelEscaped = escapeHtml(statusLabel);
        const metaNomeEscaped = escapeHtml(m.nome || "");
        const descricao = String(m.descricao || "").trim();
        const descricaoEscaped = escapeHtml(descricao);
        const dataInicioStr = dInicio ? dInicio.toLocaleDateString("pt-BR") : "";
        const dataInicioEscaped = escapeHtml(dataInicioStr);
        const dataLimiteStr = dLimite ? dLimite.toLocaleDateString("pt-BR") : "";
        const dataLimiteEscaped = escapeHtml(dataLimiteStr);
        const percentualExecutado = alocado ? Math.min(100, Math.round((executado / alocado) * 100)) : 0;
        return `
          <button type="button"
                  class="meta-card"
                  data-id="${m.id}"
                  data-programadas="${programadas}"
                  data-alocado="${alocado}"
                  data-meta-descricao="${descricaoEscaped}"
                  data-start-month="${startMonthKey}"
                  data-end-month="${endMonthKey}"
                  data-start-year="${startYearKey}"
                  data-end-year="${endYearKey}"
                  data-month="${monthKey}"
                  data-year="${yearKey}"
                  data-status="${normalizedStatus}">
            <div class="meta-head">
              <span class="icon"><i class="bi bi-flag"></i></span>
              <h6 class="meta-title">${metaNomeEscaped}</h6>
              <span class="meta-status-pill status-${normalizedStatus}" aria-label="Status: ${statusLabelEscaped}">
                ${statusLabelEscaped}
              </span>
            </div>
            <div class="meta-sep"></div>
            ${descricao ? `<p class="meta-desc mb-0">${descricaoEscaped}</p>` : ""}
            ${dInicio ? `
              <div class="meta-date">
                <i class="bi bi-calendar-check"></i>
                <span>Data inicial:</span>
                <strong>${dataInicioEscaped}</strong>
              </div>
            ` : ""}
            ${dLimite ? `
              <div class="meta-date">
                <i class="bi bi-calendar-event"></i>
                <span>Data limite:</span>
                <strong>${dataLimiteEscaped}</strong>
              </div>
            ` : ""}
            <div class="meta-small mt-2">Em programação: <b>${programadas}</b></div>
            <div class="meta-small mt-1">Alocado nesta unidade: <b>${alocado}</b></div>
            <div class="meta-progress mt-1">
              <div class="d-flex justify-content-between summary mb-1">
                <span>Executado (unidade)</span>
                <span><b>${executado}</b> / ${alocado}</span>
              </div>
              <div class="progress"><div class="progress-bar bg-primary" style="width:${percentualExecutado}%"></div></div>
            </div>
          </button>
        `;
      }).join("");

      // === Filtros por ano e mês ===
      const cards = Array.from(metasGrid.querySelectorAll(".meta-card"));

      // popula seletor de ano (default: maior ano disponível)
      const yearSelect = document.getElementById("metasYearSelect");
      if (yearSelect) {
        const years = [];
        let hasNoDate = false;
        cards.forEach((c) => {
          const startYear = parseYearKey(c.getAttribute("data-start-year"));
          const endYear = parseYearKey(c.getAttribute("data-end-year"));
          if (startYear === null && endYear === null) {
            hasNoDate = true;
            return;
          }
          const firstYear = startYear ?? endYear;
          const lastYear = endYear ?? startYear;
          for (let y = firstYear; y <= lastYear; y += 1) {
            const yKey = String(y);
            if (!years.includes(yKey)) years.push(yKey);
          }
        });
        years.sort((a, b) => Number(b) - Number(a));

        const currentStored = NS.metaYearSelected || null;
        const currentYear = String(new Date().getFullYear());
        let defaultYear = currentStored;
        if (defaultYear === "nodate" && !hasNoDate) defaultYear = "";
        if (defaultYear && defaultYear !== "nodate" && !years.includes(defaultYear)) defaultYear = "";
        if (!defaultYear) {
          if (years.includes(currentYear)) defaultYear = currentYear;
          else if (years.length > 0) defaultYear = years[0];
          else if (hasNoDate) defaultYear = "nodate";
        }

        yearSelect.innerHTML = "";
        years.forEach((y) => {
          const opt = document.createElement("option");
          opt.value = y;
          opt.textContent = y;
          if (y === defaultYear) opt.selected = true;
          yearSelect.appendChild(opt);
        });
        if (hasNoDate) {
          const optNo = document.createElement("option");
          optNo.value = "nodate";
          optNo.textContent = "Sem data";
          if (defaultYear === "nodate") optNo.selected = true;
          yearSelect.appendChild(optNo);
        }
        if (!yearSelect.value && defaultYear) yearSelect.value = defaultYear;
        NS.metaYearSelected = yearSelect.value || "";
      }

      const buildMonthTabs = () => {
        const existingTabs = document.getElementById("metasTabs");
        if (existingTabs) existingTabs.remove();

        const selectedYear = NS.metaYearSelected || "";
        const months = [];
        const labels = {};
        cards.forEach((c) => {
          if (!cardMatchesYear(c, selectedYear)) return;
          const mk = c.getAttribute("data-month") || "nodate";
          if (mk === "nodate") return;
          if (!months.includes(mk)) {
            months.push(mk);
            try {
              const [yy, mm] = mk.split("-").map(Number);
              const dt = new Date(yy, mm - 1, 1);
              const lbl = dt.toLocaleDateString("pt-BR", { month: "long", year: "numeric" });
              labels[mk] = lbl.charAt(0).toUpperCase() + lbl.slice(1);
            } catch (_e) {
              labels[mk] = mk;
            }
          }
        });
        const requestedMonth = NS.metaDateMonth || "";
        if (requestedMonth && !months.includes(requestedMonth)) {
          months.unshift(requestedMonth);
          try {
            const [yy, mm] = requestedMonth.split("-").map(Number);
            const dt = new Date(yy, mm - 1, 1);
            const lbl = dt.toLocaleDateString("pt-BR", { month: "long", year: "numeric" });
            labels[requestedMonth] = lbl.charAt(0).toUpperCase() + lbl.slice(1);
          } catch (_e) {
            labels[requestedMonth] = requestedMonth;
          }
        }

        if (months.length === 0) {
          NS.metaMonthSelected = "";
          return;
        }

        let curMonth = "";
        if (NS.metaMonthSelected && months.includes(NS.metaMonthSelected)) {
          curMonth = NS.metaMonthSelected;
        } else {
          const now = new Date();
          const curKey = `${String(now.getFullYear())}-${String(now.getMonth() + 1).padStart(2, "0")}`;
          curMonth = months.includes(curKey) ? curKey : months[0];
          NS.metaMonthSelected = curMonth;
        }

        const parts = ["<ul class='nav nav-tabs mb-2' id='metasTabs' role='tablist'>"];
        months.forEach((k) => {
          const active = k === curMonth;
          parts.push(`<li class='nav-item' role='presentation'><button class='nav-link ${active ? "active" : ""}' data-key='${k}' type='button' role='tab'>${labels[k] || k}</button></li>`);
        });
        parts.push("</ul>");
        metasGrid.insertAdjacentHTML("beforebegin", parts.join(""));

        const applyMonthFilter = (key) => {
          NS.metaMonthSelected = key || "";
          applyFilters();
          const tabs = metasGrid.previousElementSibling?.querySelectorAll?.(".nav-link") || [];
          tabs.forEach((b) => { b.classList.toggle("active", b.getAttribute("data-key") === key); });
        };

        const tabContainer = metasGrid.previousElementSibling;
        tabContainer?.querySelectorAll?.(".nav-link")?.forEach((btn) => {
          btn.addEventListener("click", () => applyMonthFilter(btn.getAttribute("data-key")));
        });
      };

      const applyFilters = () => {
        const selectedYear = NS.metaYearSelected || "";
        const selectedMonth = NS.metaMonthSelected || "";
        const selectedMonthNumber = monthKeyToNumber(selectedMonth);
        cards.forEach((card) => {
          const cm = card.getAttribute("data-month") || "nodate";
          const startMonth = card.getAttribute("data-start-month") || "nodate";
          const endMonth = card.getAttribute("data-end-month") || cm;
          const startMonthNumber = monthKeyToNumber(startMonth);
          const endMonthNumber = monthKeyToNumber(endMonth);
          let visible = true;
          if (selectedYear) visible = cardMatchesYear(card, selectedYear);
          if (visible && selectedMonth && selectedMonthNumber !== null) {
            if (startMonthNumber !== null && selectedMonthNumber < startMonthNumber) visible = false;
            if (visible && endMonthNumber !== null && selectedMonthNumber > endMonthNumber) visible = false;
          }
          card.style.display = visible ? "" : "none";
        });
      };

      if (yearSelect) {
        yearSelect.addEventListener("change", () => {
          NS.metaYearSelected = yearSelect.value || "";
          NS.metaMonthSelected = "";
          const tabs = document.getElementById("metasTabs");
          if (tabs) tabs.remove();
          buildMonthTabs();
          applyFilters();
        });
      }

      buildMonthTabs();
      applyFilters();

      metasGrid.querySelectorAll(".meta-card").forEach((card) => {
        card.addEventListener("click", () => {
          metasGrid.querySelectorAll(".meta-card").forEach((c) => c.classList.remove("selected"));
          card.classList.add("selected");

          const metaId = card.dataset.id;
          if (!metaId) return;

          const programadas = Number(card.dataset.programadas || "0") || 0;
          const alocado = Number(card.dataset.alocado || "0") || 0;
          const container = document.getElementById("metaCardsContainer");
          const selector = `[data-meta-id="${escapeSelector(metaId)}"]`;
          const cards = container ? Array.from(container.querySelectorAll(selector)) : [];
          const existingCards = cards.length;
          const novosNaoSalvos = cards.filter((c) => !c.dataset.itemId).length;
          const totalAtual = programadas + novosNaoSalvos;

          if (!confirmLimite(totalAtual, alocado)) return;

          const metaTitulo = card.querySelector(".meta-title")?.textContent?.trim() || "";
          const metaDescricao = (card.dataset.metaDescricao || "").trim();
          const options = { metaDescricao };
          if (existingCards > 0) {
            if (!confirmDuplicado(existingCards)) {
              highlightExistingCard(metaId);
              return;
            }
            options.forceNew = true;
          }

          window.PROGRAMAR?.ensureMetaCard?.(metaId, metaTitulo, options);
        });
      });
    } catch (err) {
      metasGrid.innerHTML = `<div class="alert alert-danger">Erro ao carregar metas.</div>`;
      console.error(err);
    }
  };
})();
</script>
