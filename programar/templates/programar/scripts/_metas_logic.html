<script>
(function () {
  const NS = (window.PROGRAMAR = window.PROGRAMAR || {});
  if (NS._metasLogicLoaded) return;
  NS._metasLogicLoaded = true;

  function escapeSelector(value) {
    const raw = String(value ?? "");
    if (window.CSS && typeof window.CSS.escape === "function") {
      try { return window.CSS.escape(raw); } catch (_) { return raw; }
    }
    return raw.replace(/["\\]/g, "\\$&");
  }

  function escapeHtml(value) {
    return String(value ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#39;");
  }

  function highlightExistingCard(metaId) {
    const container = document.getElementById("metaCardsContainer");
    if (!container) return;
    const card = container.querySelector(`[data-meta-id="${escapeSelector(metaId)}"]`);
    if (!card) return;
    card.classList.add("border-warning");
    try {
      if (window.PROGRAMAR?.autoScrollModal) {
        card.scrollIntoView({ behavior: "smooth", block: "center" });
      }
    } catch(_e) {}
    setTimeout(() => card.classList.remove("border-warning"), 1500);
  }

  function confirmLimite(programadasAtual, alocado) {
    if (alocado <= 0 || programadasAtual < alocado) return true;
    return window.confirm(
      `Esta meta já possui ${programadasAtual} atividade${programadasAtual === 1 ? "" : "s"} em programação ` +
      `para a unidade, igual ou maior que o total alocado (${alocado}). Deseja programar mesmo assim?`
    );
  }

  function confirmDuplicado(existingCards) {
    if (existingCards <= 0) return true;
    const mensagem = existingCards === 1
      ? "Já existe uma atividade desta meta programada para este dia. Deseja inserir outra?"
      : `Já existem ${existingCards} atividades desta meta programadas para este dia. Deseja inserir mais uma?`;
    return window.confirm(mensagem);
  }

  NS.loadMetas = async function (dateStr = null) {
    const metasGrid = document.getElementById("metasGrid");
    if (!metasGrid) return;

    const STATUS_LABELS = {
      andamento: "Em andamento",
      concluida: "Concluída",
      encerrada: "Encerrada",
    };
    metasGrid.innerHTML = `
      <div class="placeholder-glow">
        <span class="placeholder col-12 mb-2"></span>
      </div>
    `;

    let url = NS.urls?.metas;
    if (!url) {
      metasGrid.innerHTML = `<div class="alert alert-danger">Endpoint de metas não configurado.</div>`;
      return;
    }
    if (dateStr) {
      url += (url.includes("?") ? "&" : "?") + "data=" + encodeURIComponent(dateStr);
    }

    try {
      const resp = await fetch(url, { headers: { "X-Requested-With": "XMLHttpRequest" } });
      const data = await resp.json();

      if (!data.metas || !Array.isArray(data.metas) || data.metas.length === 0) {
        metasGrid.innerHTML = `<div class="alert alert-light border mb-0">Nenhuma meta disponível.</div>`;
        return;
      }

      metasGrid.innerHTML = data.metas.map((m) => {
        const programadas = Number(m.programadas_total || 0);
        const alocado = Number(m.alocado_unidade || 0);
        const executado = Number(m.executado_unidade || 0);
        const d = m.data_limite ? new Date(m.data_limite) : null;
        const monthKey = d ? (d.getFullYear() + "-" + String(d.getMonth() + 1).padStart(2, "0")) : "nodate";
        const yearKey = d ? String(d.getFullYear()) : "nodate";
        const statusKey = String(m.status || "andamento").toLowerCase();
        const normalizedStatus = STATUS_LABELS[statusKey] ? statusKey : "andamento";
        const statusLabel = m.status_label || STATUS_LABELS[normalizedStatus] || STATUS_LABELS.andamento;
        const statusLabelEscaped = escapeHtml(statusLabel);
        const metaNomeEscaped = escapeHtml(m.nome || "");
        const descricao = String(m.descricao || "").trim();
        const descricaoEscaped = escapeHtml(descricao);
        const dataLimiteStr = d ? d.toLocaleDateString("pt-BR") : "";
        const dataLimiteEscaped = escapeHtml(dataLimiteStr);
        const percentualExecutado = alocado ? Math.min(100, Math.round((executado / alocado) * 100)) : 0;
        return `
          <button type="button"
                  class="meta-card"
                  data-id="${m.id}"
                  data-programadas="${programadas}"
                  data-alocado="${alocado}"
                  data-meta-descricao="${descricaoEscaped}"
                  data-month="${monthKey}"
                  data-year="${yearKey}"
                  data-status="${normalizedStatus}">
            <div class="meta-head">
              <span class="icon"><i class="bi bi-flag"></i></span>
              <h6 class="meta-title">${metaNomeEscaped}</h6>
              <span class="meta-status-pill status-${normalizedStatus}" aria-label="Status: ${statusLabelEscaped}">
                ${statusLabelEscaped}
              </span>
            </div>
            <div class="meta-sep"></div>
            ${descricao ? `<p class="meta-desc mb-0">${descricaoEscaped}</p>` : ""}
            ${d ? `
              <div class="meta-date">
                <i class="bi bi-calendar-event"></i>
                <span>Data limite:</span>
                <strong>${dataLimiteEscaped}</strong>
              </div>
            ` : ""}
            <div class="meta-small mt-2">Em programação: <b>${programadas}</b></div>
            <div class="meta-small mt-1">Alocado nesta unidade: <b>${alocado}</b></div>
            <div class="meta-progress mt-1">
              <div class="d-flex justify-content-between summary mb-1">
                <span>Executado (unidade)</span>
                <span><b>${executado}</b> / ${alocado}</span>
              </div>
              <div class="progress"><div class="progress-bar bg-primary" style="width:${percentualExecutado}%"></div></div>
            </div>
          </button>
        `;
      }).join("");

      // === Filtros por ano e mês ===
      const cards = Array.from(metasGrid.querySelectorAll(".meta-card"));

      // popula seletor de ano (default: maior ano disponível)
      const yearSelect = document.getElementById("metasYearSelect");
      if (yearSelect) {
        const years = [];
        let hasNoDate = false;
        cards.forEach((c) => {
          const y = c.getAttribute("data-year") || "nodate";
          if (y === "nodate") {
            hasNoDate = true;
            return;
          }
          if (!years.includes(y)) years.push(y);
        });
        years.sort((a, b) => Number(b) - Number(a));

        const currentStored = NS.metaYearSelected || null;
        const currentYear = String(new Date().getFullYear());
        let defaultYear = currentStored;
        if (!defaultYear) {
          if (years.includes(currentYear)) defaultYear = currentYear;
          else if (years.length > 0) defaultYear = years[0];
          else if (hasNoDate) defaultYear = "nodate";
        }

        yearSelect.innerHTML = "";
        years.forEach((y) => {
          const opt = document.createElement("option");
          opt.value = y;
          opt.textContent = y;
          if (y === defaultYear) opt.selected = true;
          yearSelect.appendChild(opt);
        });
        if (hasNoDate) {
          const optNo = document.createElement("option");
          optNo.value = "nodate";
          optNo.textContent = "Sem data";
          if (defaultYear === "nodate") optNo.selected = true;
          yearSelect.appendChild(optNo);
        }
        if (!yearSelect.value && defaultYear) yearSelect.value = defaultYear;
        NS.metaYearSelected = yearSelect.value || "";
      }

      const buildMonthTabs = () => {
        const existingTabs = document.getElementById("metasTabs");
        if (existingTabs) existingTabs.remove();

        const selectedYear = NS.metaYearSelected || "";
        const months = [];
        const labels = {};
        cards.forEach((c) => {
          const cy = c.getAttribute("data-year") || "nodate";
          if (selectedYear && cy !== selectedYear) return;
          const mk = c.getAttribute("data-month") || "nodate";
          if (mk === "nodate") return;
          if (!months.includes(mk)) {
            months.push(mk);
            try {
              const [yy, mm] = mk.split("-").map(Number);
              const dt = new Date(yy, mm - 1, 1);
              const lbl = dt.toLocaleDateString("pt-BR", { month: "long", year: "numeric" });
              labels[mk] = lbl.charAt(0).toUpperCase() + lbl.slice(1);
            } catch (_e) {
              labels[mk] = mk;
            }
          }
        });

        if (months.length === 0) {
          NS.metaMonthSelected = "";
          return;
        }

        let curMonth = "";
        if (NS.metaMonthSelected && months.includes(NS.metaMonthSelected)) {
          curMonth = NS.metaMonthSelected;
        } else {
          const now = new Date();
          const curKey = `${String(now.getFullYear())}-${String(now.getMonth() + 1).padStart(2, "0")}`;
          curMonth = months.includes(curKey) ? curKey : months[0];
          NS.metaMonthSelected = curMonth;
        }

        const parts = ["<ul class='nav nav-tabs mb-2' id='metasTabs' role='tablist'>"];
        months.forEach((k) => {
          const active = k === curMonth;
          parts.push(`<li class='nav-item' role='presentation'><button class='nav-link ${active ? "active" : ""}' data-key='${k}' type='button' role='tab'>${labels[k] || k}</button></li>`);
        });
        parts.push("</ul>");
        metasGrid.insertAdjacentHTML("beforebegin", parts.join(""));

        const applyMonthFilter = (key) => {
          NS.metaMonthSelected = key || "";
          applyFilters();
          const tabs = metasGrid.previousElementSibling?.querySelectorAll?.(".nav-link") || [];
          tabs.forEach((b) => { b.classList.toggle("active", b.getAttribute("data-key") === key); });
        };

        const tabContainer = metasGrid.previousElementSibling;
        tabContainer?.querySelectorAll?.(".nav-link")?.forEach((btn) => {
          btn.addEventListener("click", () => applyMonthFilter(btn.getAttribute("data-key")));
        });
      };

      const applyFilters = () => {
        const selectedYear = NS.metaYearSelected || "";
        const selectedMonth = NS.metaMonthSelected || "";
        cards.forEach((card) => {
          const cy = card.getAttribute("data-year") || "nodate";
          const cm = card.getAttribute("data-month") || "nodate";
          let visible = true;
          // Metas sem data_limite (cy === "nodate") devem sempre aparecer.
          if (selectedYear && cy !== "nodate") visible = cy === selectedYear;
          if (visible && selectedMonth && cm !== "nodate") visible = cm === selectedMonth;
          card.style.display = visible ? "" : "none";
        });
      };

      if (yearSelect) {
        yearSelect.addEventListener("change", () => {
          NS.metaYearSelected = yearSelect.value || "";
          NS.metaMonthSelected = "";
          const tabs = document.getElementById("metasTabs");
          if (tabs) tabs.remove();
          buildMonthTabs();
          applyFilters();
        });
      }

      buildMonthTabs();
      applyFilters();

      metasGrid.querySelectorAll(".meta-card").forEach((card) => {
        card.addEventListener("click", () => {
          metasGrid.querySelectorAll(".meta-card").forEach((c) => c.classList.remove("selected"));
          card.classList.add("selected");

          const metaId = card.dataset.id;
          if (!metaId) return;

          const programadas = Number(card.dataset.programadas || "0") || 0;
          const alocado = Number(card.dataset.alocado || "0") || 0;
          const container = document.getElementById("metaCardsContainer");
          const selector = `[data-meta-id="${escapeSelector(metaId)}"]`;
          const cards = container ? Array.from(container.querySelectorAll(selector)) : [];
          const existingCards = cards.length;
          const novosNaoSalvos = cards.filter((c) => !c.dataset.itemId).length;
          const totalAtual = programadas + novosNaoSalvos;

          if (!confirmLimite(totalAtual, alocado)) return;

          const metaTitulo = card.querySelector(".meta-title")?.textContent?.trim() || "";
          const metaDescricao = (card.dataset.metaDescricao || "").trim();
          const options = { metaDescricao };
          if (existingCards > 0) {
            if (!confirmDuplicado(existingCards)) {
              highlightExistingCard(metaId);
              return;
            }
            options.forceNew = true;
          }

          window.PROGRAMAR?.ensureMetaCard?.(metaId, metaTitulo, options);
        });
      });
    } catch (err) {
      metasGrid.innerHTML = `<div class="alert alert-danger">Erro ao carregar metas.</div>`;
      console.error(err);
    }
  };
})();
</script>
